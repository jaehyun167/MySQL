## 8.1 디스크 읽기 방식

인덱스에만 의존적인 용어는 아니지만 "랜덤(Random) I/O", "순차(Sequential) I/O"와 같은 디스크 읽기 방식을 먼저 간단히 알아보고 인덱스를 살피겠다.

컴퓨터의 CPU나 메모리처럼 전기적 특성을 띤 장치의 성능은 짧은 시간 동안 매우 빠른 속도로 발전 했지만 디스크 같은 기계식 장치의 성능은 상당히 제한적으로 발전했다. 비록 최근에는 자기 디스크 원 판에 의존하는 하드 디스크보다 SSD 드라이브가 많이 활용되고 있지만, 여전히 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이라는 사실에는 변함이 없다. 데이터베이스나 쿼리 튜닝에 어느 정도 지식을 갖춘 사용자가 절감하고 있듯이 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

1. **속도**  
   SSD는 물리적인 회전 부품이 없기 때문에 데이터 접근 속도가 매우 빠르다. 읽기/쓰기 속도에서 HDD보다 수배 빠르며, 대기 시간도 현저히 낮다.  
   HDD는 플래터가 회전하고 헤드가 물리적으로 데이터를 찾는 시간이 소요되므로 상대적으로 느리다.

2. **내구성**  
   SSD는 기계적 부품이 없어서 충격이나 진동에 강하며, 기계식 장치보다 훨씬 더 오래 사용할 수 있다.  
   HDD는 회전하는 부품과 이동하는 헤드가 있기 때문에 물리적 충격에 취약하고, 시간이 지나면서 마모가 발생할 수 있다.

3. **전력 효율**  
   SSD는 전력을 덜 소모한다. 특히 모바일 장치나 랩탑에서 배터리 수명을 늘릴 수 있는 장점이 있다.  
   HDD는 물리적 회전과 움직임이 필요하므로 전력 소모가 상대적으로 크다.

4. **소음**  
   SSD는 기계적 부품이 없기 때문에 무음으로 작동한다.  
   HDD는 회전하는 플래터와 이동하는 헤드에서 소음이 발생할 수 있다.

5. **가벼움과 크기**  
   SSD는 작은 크기와 가벼운 무게를 제공하므로, 휴대용 장치나 서버에서 더 효율적으로 사용될 수 있다.

6. **가격**  
   과거에는 SSD가 HDD보다 비쌌지만, 최근에는 가격이 많이 하락해 비교적 합리적인 가격으로 구매할 수 있게 되었다. 그럼에도 여전히 HDD보다 비싸다.

컴퓨터의 주요 부품별 처리 속도에서 CPU와 메모리는 초당 처리 가능한 연산 횟수가 많아 매우 빠르다. 반면, 디스크는 상대적으로 처리 속도가 매우 느리다. 그림 8.1에서 이를 확인할 수 있으며, 메모리와 디스크의 처리 속도는 10만 배 이상 차이를 보인다. 기존의 **하드 디스크 드라이브(HDD)**는 기계식 장치로, 디스크의 헤드를 물리적으로 이동시키는 시간이 걸려 속도가 제한적이다.

**SSD와 HDD 비교**  
SSD(Solid State Drive)는 기계식 하드 디스크에서 데이터를 저장하는 플래터 대신 플래시 메모리를 장착하여 전원이 꺼져도 데이터가 유지된다. HDD보다 훨씬 빠른 속도를 자랑한다.  
HDD는 순차 I/O에서 성능이 떨어지지만, SSD는 랜덤 I/O 작업에서 성능 차이를 크게 보인다.  
데이터베이스 서버에서는 대부분 랜덤 I/O가 발생하므로 SSD가 더 적합한 스토리지 솔루션이다. 순차 I/O에서는 SSD와 HDD의 성능 차이가 미미할 수 있으나, 랜덤 I/O 성능에서는 SSD가 HDD보다 훨씬 뛰어난 성능을 발휘한다.

**SSD의 장점**
- **순차 I/O와 랜덤 I/O 성능 차이**: SSD는 랜덤 I/O에서 HDD보다 뛰어난 성능을 발휘한다. 데이터베이스 서버에서는 대부분 랜덤 I/O가 발생하므로, SSD는 DBMS용 스토리지에 최적이다.
- **가격과 용량**: SSD는 HDD보다 비쌌다. 예전보다 대중화되었지만 여전히 용량이 작은 편이다. 하지만 DBMS 서버에서는 대부분 SSD가 채택되고 있다.
- **디스크 성능**: SSD는 디스크 헤드를 이동시키는 기계적인 부분이 없어서 속도가 빠르다. HDD보다 랜덤 I/O가 훨씬 빠르다.

**결론**  
- SSD는 랜덤 I/O 성능에서 뛰어나 데이터베이스 서버에서 매우 중요하다. DBMS용 스토리지에 최적이다.  
- 가격과 용량 측면에서 HDD보다 비쌌다, 하지만 대부분의 DBMS 서버는 SSD를 사용하고 있다.  
- SSD는 HDD보다 랜덤 I/O 성능이 뛰어나 데이터베이스와 같은 애플리케이션에서 더욱 효율적인 성능을 발휘한다.

---

### 8.1.2 랜덤 I/O와 순차 I/O

- **랜덤 I/O** 이라는 표현은 하드 디스크 드라이브의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.
- **순차 I/O** 역시 작업 과정은 같다.

**순차와 랜덤 비교**  
디스크 성능은 디스크 헤드를 얼마나 자주 움직이는지에 따라 결정된다. 순차 I/O는 한 번에 여러 페이지를 디스크에 기록하므로 디스크 헤드를 한 번만 움직이고, 랜덤 I/O는 각각의 페이지를 기록할 때마다 디스크 헤드를 여러 번 움직여야 한다.  
이로 인해 순차 I/O가 랜덤 I/O보다 훨씬 빠르다. 디스크에서 데이터를 읽고 쓰는 시간은 디스크 헤드를 움직이는 시간에 크게 의존하므로, 랜덤 I/O는 더 많은 시간을 소모하게 된다. 데이터베이스의 대부분 작업이 랜덤 I/O를 요구하므로, MySQL 서버는 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등의 기능을 통해 이를 최적화하고 있다.

SSD는 원판을 사용하지 않기 때문에 디스크 헤드를 이동시킬 필요가 없으나, 여전히 랜덤 I/O에서 순차 I/O보다 성능이 낮을 수 있다.  
그래서 SSD의 성능 사양에서는 순차 I/O와 랜덤 I/O 성능을 구분해서 명시한다.

---

**일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.**  
랜덤 I/O 자체를 줄인다는 말은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

## 8.2 인덱스란?

인덱스는 데이터베이스에서 **빠른 검색**을 위해 사용되는 자료 구조이다.  
예를 들어, 책의 찾아보기는 특정 내용을 빠르게 찾을 수 있도록 정렬된 형태로 제공된다.  
데이터베이스에서도 이와 비슷하게 인덱스를 사용하여 데이터를 빠르게 검색할 수 있다.

책의 찾아보기를 통해 페이지 번호를 찾는 것처럼, DBMS에서는 **칼럼 값과 해당 레코드 주소를 쌍으로 만들어 인덱스를 구축**한다.  
인덱스의 핵심은 **정렬**이다. 책의 찾아보기처럼 DBMS의 인덱스도 미리 칼럼 값을 정렬하여 저장함으로써 빠른 검색이 가능하다.

---

### 자료 구조와 비교

- **SortedList**와 **ArrayList**는 프로그래밍 언어에서 자주 사용하는 자료 구조다.
- `SortedList`는 DBMS의 인덱스처럼 값을 **정렬된 상태로 유지**한다.
- `ArrayList`는 데이터 파일처럼 **값이 저장된 순서대로 유지**된다.

| 항목 | SortedList (인덱스처럼) | ArrayList (데이터 파일처럼) |
|------|------------------------|-----------------------------|
| 정렬 | 자동 정렬됨              | 입력 순서대로 유지됨         |
| 검색 속도 | 빠름                 | 느림                         |
| 저장 속도 | 느림 (정렬 필요)       | 빠름                         |

- 인덱스는 정렬된 값을 유지해야 하므로, 데이터를 삽입할 때마다 정렬 과정이 필요하다.
- 이로 인해 **저장 속도는 느려지지만**, **검색 속도는 매우 빨라진다**.

---

### 장단점

- **장점**: 빠른 검색 속도 (SELECT 성능 향상)
- **단점**: INSERT, UPDATE, DELETE 시 성능 저하 (정렬 비용)

> 결론:  
> 인덱스는 **데이터 저장 성능을 희생하고**, **데이터 읽기 성능을 향상**시키는 역할을 한다.  
> 인덱스를 추가할지는 **읽기 vs 쓰기 성능**의 균형에 따라 결정해야 한다.

---

### 인덱스의 분류

#### 1. 용도에 따른 분류

- **Primary Key (프라이머리 키)**  
  - 레코드를 고유하게 식별하는 칼럼에 대해 생성된 인덱스  
  - **NULL 불가, 중복 불가**

- **Secondary Index (세컨더리 인덱스)**  
  - 프라이머리 키를 제외한 나머지 인덱스  
  - **Unique Index (유니크 인덱스)**는 중복을 허용하지 않으며, 프라이머리 키를 대체할 수도 있음 → **Alternative Key (대체 키)**

---

#### 2. 알고리즘에 따른 분류

- **B-Tree 인덱스**
  - 가장 일반적인 인덱스
  - 칼럼 값을 그대로 인덱싱
  - MySQL에서는 R-Tree도 B-Tree 응용으로 사용됨

- **Hash 인덱스**
  - 칼럼 값을 **해시값**으로 변환하여 인덱싱
  - 매우 빠른 검색 제공
  - **전방 일치(Prefix Match)**, **범위 검색**에는 부적합
  - 메모리 기반 DB에서 주로 사용

- **기타 인덱스**
  - Fractal-Tree, Merge-Tree 등 최근 개발된 고성능 인덱스 알고리즘 존재

---

#### 3. 중복 값 허용 여부에 따른 분류

| 분류 | 설명 |
|------|------|
| **Unique Index** | 동일한 값 1개만 존재 가능. 항상 1개의 레코드 반환 |
| **Non-Unique Index** | 동일한 값 여러 개 존재 가능. 다수 레코드 반환 가능 |

---

### 요약

- 인덱스는 **읽기 성능 향상을 위한 핵심 도구**이다.
- 정렬 유지가 필요하므로 저장 성능은 떨어지지만, 검색 성능은 비약적으로 향상된다.
- 인덱스는 용도, 알고리즘, 중복 여부 등에 따라 여러 방식으로 분류되며,
- **적절한 인덱스 선택은 전체 DB 성능 개선의 핵심**이다.

### 8.3 B-Tree 인덱스
B-Tree는 가장 오래되고 널리 사용되는 데이터베이스 인덱스 알고리즘이다. DBMS에서는 주로 B+-Tree 또는 B-Tree* 형태로 변형해 사용한다.

B-Tree의 'B'는 "Balanced(균형)"를 의미한다. (Binary가 아님)  
B-Tree는 칼럼 값을 변형하지 않고, 인덱스 구조 내에서 항상 정렬된 상태를 유지한다.  
대부분의 일반적인 검색 작업에 가장 적합하다.

#### 8.3.1 B-Tree 구조와 특징
B-Tree 인덱스는 트리 구조를 가지며, 노드는 크게 세 가지로 구성된다:

| 노드 종류               | 설명                                                          |
|----------------------|-------------------------------------------------------------|
| 루트 노드 (Root Node)     | 트리의 최상단에 있는 시작 지점                                       |
| 브랜치 노드 (Branch Node)  | 루트와 리프 사이에 존재하는 중간 노드                                    |
| 리프 노드 (Leaf Node)      | 트리의 가장 아래에 위치하며, 실제 데이터의 주솟값을 가짐                        |

B-Tree 인덱스의 구조  
위 그림에서 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.  
INSERT된 순서대로 저장되는 것이 아니다. 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되는 것은 아니다.

#### MyISAM 테이블의 인덱스 구조
MyISAM 테이블은 인덱스에 레코드의 물리적 주소를 저장한다.  
이 "레코드 주소"는 테이블 생성 시 설정에 따라
➔ 레코드 삽입 순번이 될 수도 있고,  
➔ 데이터 파일 안에서의 위치(Offset) 이 될 수도 있다.  
세컨더리 인덱스도 마찬가지로 물리적 위치를 직접 저장한다.  
따라서 MyISAM에서는 인덱스를 통해
➔ 바로 데이터 파일의 레코드로 이동할 수 있다.

#### InnoDB 테이블의 인덱스 구조
InnoDB는 인덱스에 레코드의 물리적 주소를 저장하지 않는다.  
대신, 프라이머리 키 값을 저장해서 레코드를 찾는다.  
세컨더리 인덱스는 데이터 레코드의 실제 위치를 모르고, 대신 프라이머리 키 값을 가지고 있다.  
InnoDB에서는 세컨더리 인덱스를 이용해 레코드를 읽을 때
1. 먼저 프라이머리 키 값을 찾고,
2. 그 키 값을 이용해 다시 프라이머리 키 인덱스를 검색해 레코드를 읽는다.  
즉, InnoDB는 항상 프라이머리 키 인덱스를 한 번 더 탐색해야 최종 데이터에 도달한다.  
이 구조 덕분에 데이터 무결성과 트랜잭션 기능을 자연스럽게 지원할 수 있다.  
MyISAM은 인덱스가 레코드 물리적 위치를 바로 가리킨다.  
InnoDB는 인덱스가 레코드 프라이머리 키를 통해 간접적으로 가리킨다.

#### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

##### 8.3.2.1 인덱스 키 추가
레코드를 저장하거나 수정하면, 새로운 키를 B-Tree에 추가해야 함.  
새로운 키를 추가할 때는:
- B-Tree를 검색해 적절한 위치를 찾고,
- 리프 노드에 키와 레코드 주소를 저장함.  
만약 리프 노드가 꽉 차면 ➔ Split(분리) 발생 ➔ 상위 브랜치 노드까지 재구성할 수도 있음.  
B-Tree는 읽기보다 쓰기 비용이 더 큼 (디스크 읽기/쓰기 때문).  
대략적인 비용 예측:  
테이블에 레코드를 추가하는 기본 비용을 1이라고 가정하면,  
인덱스 하나 추가 비용은 약 1.5 정도.  
인덱스가 3개면 ➔ (1 + 1.5 × 3) = 5.5배 정도 작업량.

- MyISAM, MEMORY 엔진:  
  INSERT 하면 즉시 인덱스 수정.
- InnoDB 엔진:  
  인덱스 키 추가를 지연(버퍼링) 할 수도 있음.  
  단, 프라이머리 키나 유니크 인덱스는 즉시 추가 (중복 체크 필요).  
  (※ InnoDB의 '체인지 버퍼' 설명은 4.2.10절 참고.)

##### 8.3.2.2 인덱스 키 삭제
키 삭제는 단순히:
- 리프 노드를 찾아서,
- 해당 키를 삭제 마크만 하면 끝.  
삭제된 키 공간은 그냥 놔두거나 재활용할 수 있음.  
삭제 마크 작업도 디스크 쓰기가 필요함.

- InnoDB 엔진:  
  삭제도 버퍼링되어 나중에 처리할 수 있음.  
  서버가 내부적으로 관리하므로 사용자 입장에서는 신경쓸 필요 없음.
- MyISAM, MEMORY 엔진:  
  체인지 버퍼 기능 없음 ➔ 삭제 즉시 완료.

##### 8.3.2.3 인덱스 키 변경
B-Tree에서는 키 값을 직접 수정할 수 없음.  
키 값이 바뀌면:
- 기존 키를 삭제하고,
- 새로운 키를 추가하는 방식으로 처리함.  
이 과정도 체인지 버퍼를 활용해서 지연 처리할 수 있음 (InnoDB).

#### 8.3.2.4 인덱스 키 검색
인덱스를 사용하는 이유 = 빠른 검색 때문.  
B-Tree 검색 방법:
- 루트 노드부터,
- 브랜치 노드를 거쳐,
- 최종 리프 노드까지 이동하며 비교.  
이 과정을 트리 탐색이라고 함.  
검색은 SELECT뿐만 아니라, UPDATE나 DELETE에서도 사용됨 (수정/삭제 전에 먼저 찾아야 하니까).  
B-Tree는 다음 조건에서만 빠른 검색 가능:
- 100% 값 일치
- 앞부분(Left-most part) 일치
- 부등호(>, <, >=, <=) 비교

다음 경우에는 B-Tree 인덱스를 사용할 수 없음:
- 인덱스 키에 변형(함수, 연산 등)이 가해진 경우.

InnoDB의 경우:
- 레코드 잠금(Record Lock)이나 넥스트 키락(Next Key Lock)이 인덱스를 통해 걸림.  
- 인덱스를 잘못 설계하면 UPDATE/DELETE 시 테이블 전체를 잠글 수도 있음.  
그래서 InnoDB에서는 인덱스 설계가 엄청 중요함.

#### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
인덱스는 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

##### 8.3.3.1 인덱스 키 값의 크기
InnoDB 스토리지 엔진은 데이터를 페이지(Page) 단위로 관리하고, 디스크 읽기/쓰기의 최소 단위도 페이지다. (버퍼 풀에서도 페이지 단위로 버퍼링)  
인덱스 역시 페이지 단위로 구성되며, 그림 8.4에서 본 루트, 브랜치, 리프 노드는 모두 페이지 기준이다.  
B-Tree의 "B"는 이진(Binary)이 아니라, 자식 노드 개수가 가변적인 구조를 의미한다.  

자식 노드 수 결정  
MySQL InnoDB에서 자식 노드 수는 페이지 크기와 키 값 크기에 따라 달라진다.  
페이지 기본 크기는 16KB (변경 가능: innodb_page_size 변수 사용, 4KB~64KB 선택 가능).  

인덱스 키 크기에 따른 저장 가능 개수 예시  
- 키 크기 16바이트 가정 시:  
  자식 노드 주소(평균 12바이트) 포함 계산 ➔  
  16 * 1024 / (16+12) ≈ 585개 키 저장 가능.  
- 키 크기 32바이트로 늘어나면:  
  16 * 1024 / (32+12) ≈ 372개 키 저장 가능.  

결론: 키 값이 커질수록 한 페이지에 저장 가능한 키 수가 줄고, 디스크 읽기 횟수가 늘어나 성능이 저하된다.

추가 영향  
- 키 값이 커질수록 전체 인덱스 크기도 커진다.  
- InnoDB 버퍼 풀이나 MyISAM 키 캐시 메모리에는 더 적은 키만 캐싱할 수 있어, 메모리 효율도 떨어진다.

##### 8.3.3.2 B-Tree 깊이
B-Tree 인덱스의 깊이(Depth)는 검색 성능에 직접적인 영향을 준다.  
깊이는 직접 제어할 수 없으며, 키 크기와 레코드 수에 따라 자연스럽게 결정된다.

키 크기에 따른 최대 키 수  
- 키 크기 16바이트일 때 깊이 3:  
  585 × 585 × 585 ≈ 2억 개 키 저장 가능.  
- 키 크기 32바이트일 때 깊이 3:  
  372 × 372 × 372 ≈ 5천만 개 키 저장 가능.  

결론: 키 값이 커지면 B-Tree의 Depth가 빨리 깊어지고, 검색 시 랜덤 디스크 I/O가 증가한다.

참고  
실제로는 대용량 데이터베이스에서도 B-Tree 깊이가 5단계 이상 되는 경우는 드물다.

##### 8.3.3.3 선택도(Selectivity) / 기수성(Cardinality)
선택도(Selectivity)와 기수성(Cardinality)은 거의 같은 의미로 사용된다.  
기수성: 전체 인덱스 키 값 중 유니크한 값의 수.  
예: 전체 100개 키 값 중 10개만 유니크 ➔ 기수성 = 10  
선택도: 인덱스를 이용해 검색 시 걸러낼 수 있는 정도.  

특징  
- 중복된 키 값이 많으면 ➔ 기수성 ↓, 선택도 ↓  
- 선택도가 높을수록 ➔ 검색 대상 줄어듦 ➔ 빠른 검색 성능 기대 가능.  

결론: 인덱스는 선택도/기수성이 높을수록 성능에 유리하다.

**예제: country, city 컬럼을 가진 tb_test 테이블**  
테이블: tb_test  
전체 레코드 수: 10,000건  
인덱스: country 칼럼에만 생성  

```sql
mysql> SELECT * 
       FROM tb_test
       WHERE country = 'KOREA' AND city = 'SEOUL';

