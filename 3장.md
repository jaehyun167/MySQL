# 3장 사용자 계정 및 권한 관리
MySQL. 8.0 버전부터는 권한을 묶어서 관리하는 역할(Role. 롤)의 개념이 도입됐기 때문에 각 사용자의 권한으로 미리 준비된 권한 세트(Role)를 부여하는 것도 가능하다. 

 

3.1 사용자 식별

MySQL의 사용자는 다른 DBMS와는 조금 다르게 사용자의 계정뿐 아니라 사용자의 접속 지점도 계정의 일부가 된다. 따라서 MySQLㅇ네서 계정을 언급할 때는 다음과 같이 항상 아이디와 호스트를 함께 명시해야 한다. 아이디와 IP 주소를 감싸는 역 따옴표는 MySQL에서 식별자를 감싸는 따옴표 역할을 하는데, 이는 종종 홑따옴표로도 바뀌어서 사용되기도 한다.

'svc_id'@'127.0.0.1'
svc_id라는 아이디로 접속할 때만 사용될 수 있는 계정이다. 만약 사용자 계정에 다음과 같은 계정만 등록돼 있다면 다른 컴퓨터에서는 svc_id라는 아이디로 접속할 수 없음을 의미한다.

 

svc_id'@'192.168.0.10' (이 계정의 비밀번호는 123)
svc_id'@'%' (이 계정의 비밀번호는 abc)
ip주소가 192.168.0.10인 PC에서 이 MySQL 서버에 접속할 때 MySQL 서버가 첫 번째 계정 정보를 이용해 인증을 실행할지, 아니면 두 번째 계정 정보를 이용할지에 따라 이 접속은 성공할 수도 있고 실패할 수도 있다.

 

3.2 사용자 계정 관리

3.2.1 시스템 계정과 일반 계정

MySQL 8.0부터 계정은 SYSTEM_USER 권한을 가지고 있느냐에 따라 시스템 계정과 일반계정으로 구분된다. 여기서 소개하는 시스템 계정은 MySQL  서버 내부적으로 실행되는 백그라운드 스레드와는 무관하며, 시스템 계정도 일반 계정과 같이 사용자를 위한 계정이다.

 

시스템 계정은 시스템 계정과 일반 계정을 관리할 수 있지만 일반 계정은 시스템 계정을 관리할 수 없다.
데이터베이스 서버 관리와 관련된 중요 작업은 시스템 계정으로만 수행할 수 있다. 
시스템 계정의 권한

계정관리, 다른 세션 또는 그 세션에서 실행 중인 쿼리를 강제 종료, 스토어드 프로그램 생성시 DEFINER를 타 사용자로 설정할 수 있다.

 

3.2.2 계정 생성

MySQL 5.7버전까지는 FRANT 명령으로 권한의 부여와 동시에 계정 생성이 가능하다.

하지만 MySQL 8.0 버전부터는 계정의 생성은 CREATE USER 명령으로, 권한 부여는 FRANT 명령으로 구분해서 실행하도록 바뀌었다. 계정을 생성할 때는 다음과 같은 다양한 옵션을 설정할 수 있다.

계정의 인증 방식과 비밀번호
비밀번호 관련 옵션(유효 기간, 이력 개수, 재사용 불가 기간)
기본 역할
SSL 옵션
계정 잠금 여부
mysql> CREATE USER 'user'@'%'
IDENTIFIED WITH 'mysql_native_password' BY 'password'
REQUIRE NONE PASSWORD EXPIRE INTERVAL 180 DAY
ACCOUNT UNLOCK
PASSWORD HISTORY 3
PASSWORD REUSE INTERVAL DEFAULT
PASSWORD REQUIRE CURRENT DEFAULT;
 

3.2.2.1 IDENTIFIED WITH

사용자의 인증 방식과 비밀번호를 설정한다.  IDENTIFIED WITH 뒤에는 반드시 인증방식을 명시해야 하는데, MySQL 서버의 기본 인증 방식을 사용하고자 한다면 IDENTIFIED BY 'password' 형식으로 명시해야 한다. MySQL 서버에서는 다양한 인증 방식을 플러그인 형태로 제공하며, 다음 4가지 방식이 가장 대표적이다.

Native Pluggable Authentication - 클라이언트가 보낸 값과 해시값이 일치하는지 비교하는 인증 방식
Caching SHA-2 Pluggable Authentication -암호값 해시값 생성을 위해 SHA-2 알고리즘을 사용한다.
PAM Pluggable Authentication - 유닉스 패스워드 또는 LDAP와 같은 외부 인증을 사용할 수 있게 해주는 인증 방식이다.
LDAP Pluggable Authentication - LDAP을 이용한 외부 인증을 사용할 수 있게 해주는 인증 방식이다.
3.2.2.2 REQUIRE

MySQL 서버에 접속할 때 암호화된 SSL/TLS 채널을 사용할지 여부를 설정한다. 만약 별도로 설정하지 않으면 비암호화 채널로 연결하게 된다.

 

3.2.2.3 PASSWORD EXPIRE

비밀번호의 유효 기간을 설정하는 옵션, 별도로 명시하지 않으면 default_poassword_lifetion 시스템 변수에 저장된 기간으로 유효 기간이 설정된다. 

PASSWORD EXPIRE - 계정 생성과 동시에 비밀번호 만료 처리
PASSWORD EXPIRE INTERVAL n DAY - n일 후 비밀번호 만료 처리
 PASSWORD EXPIRE NEVER - 비밀번호 만료 기간 없다.
PASSWORD EXPIRE DEFAULT - default_password_lifetime 시스템 변수 저장된 기간으로 비밀번호의 유효 기간을 설정
PASSWORD EXPIRE INTERVAL n DAY -  비밀번호 유효기간을 오늘부터 n일자로 설정
3.2.2.4 PASSWORD HISTORY

한 번 사용했던 비밀번호를 재사용하지 못하게 설정하는 옵션, PASSWORD HISTORY 절에 설정 가능한 옵션은 다음과 같다.

PASSWORD HISTORY DEFAULT - password_history 시스템 변수에 저장된 개수만큼 이력을 저장하며, 이력에 남아있는 비밀번호는 재사용할 수 없다.
PASSWORD HISTORY n - 비밀번호 이력을 최근 n개까지만 자정하며, 남아있는 비밀번호를 재사용할 수 없다.
3.2.2.5 PASSWORD REUSE INTERVAL

한 번 사용했던 비밀번호의 재사용 금지 기간을 설정하는 옵션이며, 별도로 명시하지 않으면 password_reuse_interval 시스템 변수에 저장된 기간으로 설정된다.

PASSWORD REUSE INTERVAL DEFAULT - password_reuse_interval 변수에 저장된 기간으로 설정
PASSWORD REUSE INTERVAL n DAY - n일 후에 비밀번호 재사용할 수 있게 설정
3.2.2.6 PASSWORD REQUIRE

비밀번호가 만료되어 새로운 비밀번호로 변경할 때 현재 비밀번호를 필요로 할지 말지를 결정하는 옵션이며, 별도로 명시되지 않으면 password_reuse_current 시스템 변수의 값으로 설정된다. 

PASSWORD REQUIRE CURRENT - 비밀번호 변경할 때, 현재 비밀번호를 먼저 입력하도록 설정
PASSWORD REQUIRE OPTIONAL - 비밀번호 변경할 때,  현재 비밀번호를 입력하지 않아도 되도록 설정
PASSWORD REQUIRE DEFAULT -  password_require_current 시스템 변수의 값으로 설정
3.2.2.7 ACCOUNT LOCK/UNLOCK

계정 생성 시 또는 ALTER USER 명령을 사용해 계정 정보를 변경할 때 계정을 사용하지 못하게 잠글지 여부를 결정한다.

ACCOUNT LOCK - 계정을 사용하지 못하게 잠금
ACCOUNT UNLOCK - 잠긴 계정을 다시 사용 가능 상태로 잠금 해제
3.3 비밀번호 관리

3.3.1 고수준 비밀번호

MySQL 서버의 비밀번호는 유효기간이나 이력 관리를 통한 재사용 금지 기능뿐만 아니라 비밀번호를 쉽게 유추할 수 있는 단어들이 사용되지 않게 글자의 조합을 강제하거나 금칙어를 설장하는 기능도 있다. 

 

3.3.2 이중 비밀번호

일반적으로 많은 응용 프로그램 서버들이 공용으로 데이터베이스 서버를 사용하기 때문에 데이터베이스 서버의 계정 정보는 응용 프로그램 서버로부터 공용으로 사용되는 경우가 많다. 서비스에서 데이터 베이스 계정의 비밀번호는 처음 설정한 상태로 몇 년 동안 사용되는 경우가 많다.

이 같은 문제점을 해결하기 위해 MySQL 8.0 버전부터는 계정의 비밀번호로 2개의 값을 동시에 사용할 수 있는 기능을 추가햇다.

 

3.4 권한

MySQL 5/7 버전까지 권한은 글로벌 권한과 객체 단위의 권한으로 구분된다. 데이터베이스나 테이블 이외의 객체에 적용되는 권한을 글로벌 권한이라고 하며, 데이터베이스나 테이블을 제어하는 데 필요한 권한을 객체 권한이라 한다.

 

사용자에게 권한 부여할 때는 GRANT 명령을 사용한다.

mysql> GRANT privilege_list ON db.table TO 'user'@'host';
 

글로벌 권한

mysql> GRANT SUPER ON *.* TO 'user'@'localhost';
특정 DB나 테이블에 부여될 수 없기 때문에 글로벌 권한을 부여할 때 GRANT 명령의 ON절에는 항상 *.*를 사용하게 된다.

 

DB권한

mysql> GRANT EVENT ON *.* TO 'user'@'localhost';
mysql> GRANT EVENT ON employees.* TO 'user'@'localhost';
특정 DB에 대해서만 권한을 부여하거나 서버에 존재하는 모든 DB에대한 권한을 부여할 수 있기 때문에 위의 예제와 같이 ON 절에 *.*이나 employees.*모두 사용할 수 있다. 

 

테이블 권한

mysql> GRANT SELECT ON *.* TO 'user'@'localhost';
mysql> GRANT SELECT ON employees.* TO 'user'@'localhost';
mysql> GRANT SELECT ON employees.employees TO 'user'@'localhost';
모든 db에 대해 권한을 부여하는 것도 가능하며, 특정 db의 오브젝트에 대해서만 권한을 부여하는 것도 가능하다. 그리고 특정 db의 특정 테이블에 대해서만 권한을 부여하는 것도 가능하다. 

 

3.5 역할

MySQL 8.0 버전부터 권한을 묶어서 역할을 사용할 수 있게 됐다. 실제 MySQL 서버 내부적으로 역할은 계정과 똑같은 모습을 하고 있다. 

creat role 명령을 이용해 role_emp_read와 role}_emp_write라는 이름의 역할을 정의한다.
mysql> CREATE ROLE 'role_emp_read', 'role_emp_write';
빈 껍데기만 있는 역할을 정의한 것이다.

GRANT 명령으로 각 역할에 대해 실질적인 권한을 부여한다.
mysql> GRANT SELECT ON employees.* TO 'role_emp_read';
mysql> GRANT INSERT, UPDATE, DELETE ON employees.* TO 'role_emp_write';
기본적인 역할은 그 자체로 사용될 수 없고 계정에 부여해야 하므로 CREATE USER 명령으로 reader와 writer라는 계정을 생성

mysql> CREATE USER reader@'127.0.0.1' IDENTIFIED BY 'password';
mysql> CREATE USER writer@'127.0.0.1' IDENTIFIED BY 'password';
 

GRANT 명령으로 reader와 writer라는 계정에 역할 부여
mysql> GRANT role_emp_read TO reader@'127.0.0.1';
mysql> GRANT role_emp_write TO writer@'127.0.0.1';
 이 상태에서 reader나 writer 계정으로 로그인해서 employees DB 데이터를 조회하거나 변경하려고 하면 권한이 없다는 에러가 뜬다.

mysql> SELECT * FROM employees.employees LIMIT 10; ERROR 1142 (42000):
mysql> SELECT command denied to user 'reader'@'localhost' for table 'employees
실제 역할은 부여되었지만 계정의 활성화된 역할을 조회해 보면 role_emp_read역할이 없음을 확인 할 수 있다.

 

 reader 계정이 role emp read 역할을 사용할수 있게 하려면 다음과 같이 SET ROLE 명령을 실행해 해당 역할을 활성화해야 한다. 일단 역할이 활성화되면 그 역할이 가진 권한은 사용할 수 있는 상태가 되지만 계정이 로그아웃됐다가 다시 로그인하면 역할이 활성화되지 않은 상태로 초기화돼 버린다.
mysql> SET ROLE 'role emp_read';
mysql> SELECT current_rol ();
mysql> SELECT COUNT(*) FROM employees.employees;
시스템 변수가 ON이 되면 역할을 활성화하지 않아도 로그인과 동시에 부여된 역할이 자동으로 활성화된다.
mysql> SET GLOBAL activate_all_roles_on_login = ON;
CREATE USER 명령으로 계정을 생성할 때는 reader@'127.0.0.1'과 같이 계정 이름과 호스트 부분을 함께 명시한다. 하지만 CREATE ROLE 명령으로 역할을 생성할 때는 호스트 부분을 별도로 명시하지 않았다. 이것이 역할과 계정의 차이처럼 보일 수 있지만 사실은 호스트 부분을 명시하지 않은 경우 에는 자동으로 '모든 호스트(%)가 자동으로 추가된다. 즉, 다음 2개의 CREATE ROLE 명령은 동일한 '역할 (Role)'을 만들게 된다. 그래서 mysql DB의 user 테이블을 조회했을 때 두 역할의 host 칼럼의 값이 '%' 로 나타난 것이다. 또한 계정을 생성할 때도 'reader"라고 계정의 이름만 명시하면 reader@'%'와 동일한 계정이 생성된다.

mysql> CREATE ROLE
               role_emp_read,
               role_emp_write;

mysql> CREATE ROLE
               role_emp_read@'%',
               role_emp_write@'%';
 

mysql>  CREATE ROLE role_emp_local_read@localhost;

mysql>  CREATE USER reader@localhost IDENTIFIED BY 'qwerty';

mysql>  GRANT SELECT ON employees.* TO role_emp_local_read@'localhost';

mysql>  GRANT role_emp_local_read@localhost TO reader@'127.0.0.1';
role emp_ local_ reade localhost' 역할을 reader @ '127.0.0.1' 계정에 부여하는 예제다. 역할과 계정의 호스트 부분이 서로 달라서 호한되지 않는 상태인데. 이는 역할의 호스트 부분이 어떤 영향을 미치는지 살펴보기 위한 것이다.  역할과 계정을 생성하면 사용자 계정은 employes DB의 객체들에 대해 SELECT 권한이 부여된다. 즉, 역할의 호스트 부분은 아무런 영향이 없다. 역할을 다른 계정에 부여하지 않고 직접 로그인하는 용도로 사용한다면(실제 계정처럼 사용한다면) 그때는 역할의 호스트 부분이 중요해진다.


